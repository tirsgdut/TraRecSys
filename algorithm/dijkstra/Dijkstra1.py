import networkx as nximport time# 输入图像，计算距离的起始点和终点；def Dijkstra(G, start, end):    if start > end:        start, end = end, start    RG = G.reverse()    # 记录距离的字典    dict_ = {}    previous = {}    # 初始化:每个点对应的距离为 ：无穷大    for v in RG.nodes():        dict_[v] = float('inf')        previous[v] = 'None'    # 目标终点设为0    dict_[end] = 0    u = end    # 直到遍历到终点    while u != start:        # 获取距离最小部分        u = min(dict_, key=dict_.get)        # 记录最小距离        distu = dict_[u]        # 删除距离最小的键值对，去除已选择的结点        del(dict_[u])        # 返回有连接关系的两点;找最小权值的对应关系        # 只选择与最短权值有关的边进行遍历比较        for u, v in RG.edges(u):            if v in dict_:                alt = distu + RG[u][v]['weight']                if alt < dict_[v]:                    dict_[v] = alt                    # 记录改权值最小的边                    previous[v] = u    # 输出路径    path = (start,)    last = start    # 加上下一个结点    while last != end:        nxt = previous[last]        path += (nxt,)        last = nxt    return pathdef main():    #画出图像    G = nx.DiGraph()    G.add_edge(0, 1, weight=80)    G.add_edge(1, 2, weight=50)    G.add_edge(1, 3, weight=30)    G.add_edge(3, 2, weight=10)    G.add_edge(2, 4, weight=20)    G.add_edge(2, 5, weight=30)    G.add_edge(4, 5, weight=10)    G.add_edge(5, 3, weight=5)    G.add_edge(2, 6, weight=10)    G.add_edge(4, 6, weight=10)    G.add_edge(3, 6, weight=25)    G.add_edge(5, 6, weight=35)    start = 6    end = 3    startTime = time.time()    result= Dijkstra(G, start, end)    print(result)    print("本次运行共花费了：%f s" % (time.time()-startTime))main()