# 封装算法说明："""需要导入：1、各个顶点间的权值矩阵；          2、起始点、终点；结果：1、最短路程和最短路程对应的顶点；函数：1、将矩阵画成有向图函数：get_G(self)      2、算法实现函数，返回最短的路径"""import numpy as npimport pandas as pdimport networkx as nximport mathimport timeclass dijkstra(object):    def __init__(self, Matrix, start, end):        self.Matrix = Matrix        self.start = start        self.end = end    # 将矩阵画成有向图函数：get_G(self)    def get_G(self):        G = nx.DiGraph()        for i in range(len(self.Matrix)):            for j in range(len(self.Matrix)):                G.add_edge(i, j, weight = self.Matrix[i][j])        return G    # 输入图像，计算距离的起始点和终点；    def run_dijkstra(self):        flag = 'positive'        if self.start > self.end:            self.start, self.end = self.end, self.start            flag = 'Reverse'        G = self.get_G()        RG = G.reverse()        # 记录距离的字典        dict_ = {}        # 记录两点关系        previous = {}        # 初始化        for v in RG.nodes():            dict_[v] = float('inf')            previous[v] = 'None'        # 目标终点设为0        dict_[self.end] = 0        u = self.end        # 直到遍历到终点        while u != self.start:            # 获取距离最小的键            u = min(dict_, key=dict_.get)            # 记录最小距离            distu = dict_[u]            # 删除距离最小的键值对，即删除已选择过的点            del (dict_[u])            # 遍历边，末端为u的边的权重            for u, v in RG.edges(u):                if v in dict_:                    alt = distu + RG[u][v]['weight']                    # 记录距离最小的点、更新权值                    if alt < dict_[v]:                        dict_[v] = alt                        # 记录一组对应关系                        previous[v] = u        # 输出路径        path = (self.start,)        # 记录当前点        last = self.start        # 加上下一个结点        while last != self.end:            # 关联的下一个点            nxt = previous[last]            path += (nxt,)            last = nxt        print(path,flag)        return path, flagdef main():    #画出图像    G = nx.DiGraph()    G.add_edge(0, 1, weight=80)    G.add_edge(1, 2, weight=50)    G.add_edge(1, 3, weight=30)    G.add_edge(3, 2, weight=10)    G.add_edge(2, 4, weight=20)    G.add_edge(2, 5, weight=30)    G.add_edge(4, 5, weight=10)    G.add_edge(5, 3, weight=5)    G.add_edge(2, 6, weight=10)    G.add_edge(4, 6, weight=10)    G.add_edge(3, 6, weight=25)    G.add_edge(5, 6, weight=35)    start = 0    end = 6    startTime = time.time()    result= dijkstra(G, start, end)    H.run_dijkstra()    print(result)    print("本次运行共花费了：%f s" % (time.time()-startTime))